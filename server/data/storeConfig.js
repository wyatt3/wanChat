// Store configuration - AI-generated items
const fs = require('fs');
const path = require('path');
const ollamaService = require('../services/ollamaService');

const DATA_DIR = path.join(__dirname, '../../data');
const STORE_ITEMS_FILE = path.join(DATA_DIR, 'storeItems.json');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

// Current store items (generated by AI)
let currentItems = {};
let lastRefreshTime = 0;
let isGenerating = false;

// Fallback items if AI fails
const FALLBACK_ITEMS = {
  title_noob: {
    id: 'title_noob',
    name: 'Noob Title',
    description: 'Display [Noob] before your name',
    price: 5,
    category: 'title',
    rarity: 'common',
    prefix: '[Noob]'
  },
  collectible_rock: {
    id: 'collectible_rock',
    name: 'Pet Rock',
    description: 'Your new best friend.',
    price: 10,
    category: 'collectible',
    rarity: 'common',
    emoji: 'ğŸª¨'
  },
  title_gamer: {
    id: 'title_gamer',
    name: 'Gamer Title',
    description: 'Display [Gamer] before your name',
    price: 50,
    category: 'title',
    rarity: 'uncommon',
    prefix: '[Gamer]'
  },
  collectible_banana: {
    id: 'collectible_banana',
    name: 'Banana',
    description: 'A perfectly good banana.',
    price: 3,
    category: 'collectible',
    rarity: 'common',
    emoji: 'ğŸŒ'
  },
  title_legend: {
    id: 'title_legend',
    name: 'Legend Title',
    description: 'Display [Legend] before your name',
    price: 500,
    category: 'title',
    rarity: 'rare',
    prefix: '[Legend]'
  },
  collectible_diamond: {
    id: 'collectible_diamond',
    name: 'Fake Diamond',
    description: 'Looks real enough.',
    price: 200,
    category: 'collectible',
    rarity: 'rare',
    emoji: 'ğŸ’'
  },
  title_whale: {
    id: 'title_whale',
    name: 'Whale Title',
    description: 'Display [Whale] before your name',
    price: 5000,
    category: 'title',
    rarity: 'legendary',
    prefix: '[Whale]'
  },
  collectible_void: {
    id: 'collectible_void',
    name: 'Piece of the Void',
    description: 'Do not stare too long.',
    price: 666,
    category: 'collectible',
    rarity: 'legendary',
    emoji: 'ğŸ•³ï¸'
  },
  title_transcendent: {
    id: 'title_transcendent',
    name: 'Transcendent Title',
    description: 'Display [Transcendent] before your name',
    price: 100000,
    category: 'title',
    rarity: 'mythic',
    prefix: '[Transcendent]'
  },
  collectible_galaxy: {
    id: 'collectible_galaxy',
    name: 'Pocket Galaxy',
    description: 'A whole galaxy in your pocket.',
    price: 50000,
    category: 'collectible',
    rarity: 'mythic',
    emoji: 'ğŸŒŒ'
  }
};

// Load saved store items
function loadStoreItems() {
  try {
    if (fs.existsSync(STORE_ITEMS_FILE)) {
      const data = JSON.parse(fs.readFileSync(STORE_ITEMS_FILE, 'utf8'));
      if (data.items && data.refreshTime) {
        currentItems = data.items;
        lastRefreshTime = data.refreshTime;
        console.log(`Loaded ${Object.keys(currentItems).length} store items from disk`);
        return true;
      }
    }
  } catch (error) {
    console.error('Failed to load store items:', error.message);
  }
  return false;
}

// Save store items to disk
function saveStoreItems() {
  try {
    fs.writeFileSync(STORE_ITEMS_FILE, JSON.stringify({
      items: currentItems,
      refreshTime: lastRefreshTime
    }, null, 2));
  } catch (error) {
    console.error('Failed to save store items:', error.message);
  }
}

// Calculate current 15-minute window
function getCurrentWindow() {
  const now = new Date();
  const minutes = now.getMinutes();
  const windowMinutes = Math.floor(minutes / 15) * 15;
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), windowMinutes, 0, 0).getTime();
}

// Check if store needs refresh
function needsRefresh() {
  const currentWindow = getCurrentWindow();
  return currentWindow > lastRefreshTime;
}

// Generate new store items via AI
async function refreshStoreItems(broadcast = null) {
  if (isGenerating) {
    console.log('Store refresh already in progress...');
    return;
  }

  isGenerating = true;
  console.log('Generating new store items via AI...');

  if (broadcast) {
    broadcast('ğŸª The store is restocking with new items...');
  }

  try {
    const aiItems = await ollamaService.generateStoreItems(10);

    if (aiItems && aiItems.length > 0) {
      currentItems = {};
      aiItems.forEach(item => {
        // Ensure unique IDs
        const baseId = item.id || item.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        let id = baseId;
        let counter = 1;
        while (currentItems[id]) {
          id = `${baseId}_${counter++}`;
        }
        item.id = id;
        currentItems[id] = item;
      });

      lastRefreshTime = getCurrentWindow();
      saveStoreItems();
      console.log(`Generated ${Object.keys(currentItems).length} new store items`);

      if (broadcast) {
        broadcast(`ğŸª New items available! Check /store for ${Object.keys(currentItems).length} fresh items!`);
      }
    } else {
      throw new Error('AI returned no valid items');
    }
  } catch (error) {
    console.error('AI item generation failed, using fallback items:', error.message);
    currentItems = { ...FALLBACK_ITEMS };
    lastRefreshTime = getCurrentWindow();
    saveStoreItems();

    if (broadcast) {
      broadcast('ğŸª Store restocked with classic items');
    }
  }

  isGenerating = false;
}

// Initialize store on load
function initializeStore() {
  const loaded = loadStoreItems();
  if (!loaded || needsRefresh() || Object.keys(currentItems).length === 0) {
    // Use fallback items initially, then try to refresh with AI
    if (Object.keys(currentItems).length === 0) {
      currentItems = { ...FALLBACK_ITEMS };
      lastRefreshTime = getCurrentWindow();
    }
    // Trigger async refresh
    refreshStoreItems().catch(console.error);
  }
}

// Get available items (all current items)
function getAvailableItems() {
  // Check if we need a refresh
  if (needsRefresh() && !isGenerating) {
    refreshStoreItems().catch(console.error);
  }
  return Object.values(currentItems);
}

// Get a specific item by ID
function getItem(itemId) {
  return currentItems[itemId] || null;
}

// Get all items
function getAllItems() {
  return currentItems;
}

// Calculate time until next refresh
function getTimeUntilRefresh() {
  const now = new Date();
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  const minutesUntilRefresh = 15 - (minutes % 15) - (seconds > 0 ? 1 : 0);
  const secondsUntilRefresh = seconds > 0 ? 60 - seconds : 0;
  return { minutes: minutesUntilRefresh, seconds: secondsUntilRefresh };
}

// Manual refresh trigger (for /update command or scheduled refresh)
async function forceRefresh(broadcast = null) {
  await refreshStoreItems(broadcast);
}

// Initialize on module load
initializeStore();

module.exports = {
  getAvailableItems,
  getItem,
  getAllItems,
  getTimeUntilRefresh,
  forceRefresh,
  needsRefresh,
  isGenerating: () => isGenerating
};
