// Store configuration - AI-generated items
const fs = require('fs');
const path = require('path');
const ollamaService = require('../services/ollamaService');

const DATA_DIR = path.join(__dirname, '../../data');
const STORE_ITEMS_FILE = path.join(DATA_DIR, 'storeItems.json');

// Ensure data directory exists
if (!fs.existsSync(DATA_DIR)) {
  fs.mkdirSync(DATA_DIR, { recursive: true });
}

// Current store items (generated by AI)
let currentItems = {};
let lastRefreshTime = 0;
let isGenerating = false;
let initialLoadComplete = false;

// Load saved store items
function loadStoreItems() {
  try {
    if (fs.existsSync(STORE_ITEMS_FILE)) {
      const data = JSON.parse(fs.readFileSync(STORE_ITEMS_FILE, 'utf8'));
      if (data.items && data.refreshTime) {
        currentItems = data.items;
        lastRefreshTime = data.refreshTime;
        console.log(`Loaded ${Object.keys(currentItems).length} store items from disk`);
        return true;
      }
    }
  } catch (error) {
    console.error('Failed to load store items:', error.message);
  }
  return false;
}

// Save store items to disk
function saveStoreItems() {
  try {
    fs.writeFileSync(STORE_ITEMS_FILE, JSON.stringify({
      items: currentItems,
      refreshTime: lastRefreshTime
    }, null, 2));
  } catch (error) {
    console.error('Failed to save store items:', error.message);
  }
}

// Calculate current 15-minute window
function getCurrentWindow() {
  const now = new Date();
  const minutes = now.getMinutes();
  const windowMinutes = Math.floor(minutes / 15) * 15;
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), windowMinutes, 0, 0).getTime();
}

// Check if store needs refresh
function needsRefresh() {
  const currentWindow = getCurrentWindow();
  return currentWindow > lastRefreshTime;
}

// Generate new store items via AI (with retry on failure)
async function refreshStoreItems(broadcast = null, retryCount = 0) {
  if (isGenerating) {
    console.log('Store refresh already in progress...');
    return;
  }

  const maxRetries = 3;
  isGenerating = true;
  console.log('Generating new store items via AI...');

  if (broadcast) {
    broadcast('üè™ The store is restocking with new items...');
  }

  try {
    const aiItems = await ollamaService.generateStoreItems(10);

    if (aiItems && aiItems.length > 0) {
      currentItems = {};
      aiItems.forEach(item => {
        // Ensure unique IDs
        const baseId = item.id || item.name.toLowerCase().replace(/[^a-z0-9]/g, '_');
        let id = baseId;
        let counter = 1;
        while (currentItems[id]) {
          id = `${baseId}_${counter++}`;
        }
        item.id = id;
        currentItems[id] = item;
      });

      lastRefreshTime = getCurrentWindow();
      saveStoreItems();
      initialLoadComplete = true;
      console.log(`Generated ${Object.keys(currentItems).length} new store items`);

      if (broadcast) {
        broadcast(`üè™ New items available! Check /store for ${Object.keys(currentItems).length} fresh items!`);
      }
    } else {
      throw new Error('AI returned no valid items');
    }
  } catch (error) {
    console.error(`AI item generation failed (attempt ${retryCount + 1}/${maxRetries}):`, error.message);

    isGenerating = false;

    // Retry if we haven't exceeded max retries
    if (retryCount < maxRetries - 1) {
      console.log(`Retrying store generation in 5 seconds...`);
      if (broadcast) {
        broadcast(`üè™ Store generation failed, retrying... (${retryCount + 2}/${maxRetries})`);
      }
      await new Promise(resolve => setTimeout(resolve, 5000));
      return refreshStoreItems(broadcast, retryCount + 1);
    } else {
      console.error('All store generation attempts failed. Store will be empty until next refresh.');
      if (broadcast) {
        broadcast('üè™ Store generation failed. Try /refreshstore to retry.');
      }
    }
  }

  isGenerating = false;
}

// Initialize store on load - always generate fresh AI items on startup
async function initializeStore() {
  const loaded = loadStoreItems();

  // If we have saved items and they're not expired, use them
  if (loaded && !needsRefresh() && Object.keys(currentItems).length > 0) {
    console.log('Using cached store items');
    initialLoadComplete = true;
    return;
  }

  // Otherwise, generate new items from AI
  console.log('Generating fresh store items from AI on startup...');
  await refreshStoreItems();
}

// Get available items (all current items)
function getAvailableItems() {
  // Check if we need a refresh
  if (needsRefresh() && !isGenerating) {
    refreshStoreItems().catch(console.error);
  }
  return Object.values(currentItems);
}

// Get a specific item by ID
function getItem(itemId) {
  return currentItems[itemId] || null;
}

// Get all items
function getAllItems() {
  return currentItems;
}

// Calculate time until next refresh
function getTimeUntilRefresh() {
  const now = new Date();
  const minutes = now.getMinutes();
  const seconds = now.getSeconds();
  const minutesUntilRefresh = 15 - (minutes % 15) - (seconds > 0 ? 1 : 0);
  const secondsUntilRefresh = seconds > 0 ? 60 - seconds : 0;
  return { minutes: minutesUntilRefresh, seconds: secondsUntilRefresh };
}

// Manual refresh trigger (for /update command or scheduled refresh)
async function forceRefresh(broadcast = null) {
  await refreshStoreItems(broadcast);
}

// Initialize on module load (async)
initializeStore().catch(console.error);

module.exports = {
  getAvailableItems,
  getItem,
  getAllItems,
  getTimeUntilRefresh,
  forceRefresh,
  needsRefresh,
  isGenerating: () => isGenerating,
  isReady: () => initialLoadComplete
};
